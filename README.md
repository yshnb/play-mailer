Scala mailer module for Play 2.4.x
=====================================================

Scala wrapper around java mail which allows you to send emails. The default configuration options exposed in Configuration work using Amazon SES SMTP

Installation
------------

``` scala
  val appDependencies = Seq(
    "net.kaliber" %% "play-mailer" % "4.0.0"
  )

  resolvers += "Kaliber Repository" at "https://jars.kaliber.io/artifactory/libs-release-local"
```

Configuration
-------------

`application.conf` should contain the following information:

``` scala
mail.failTo="failto+customer@company.org"

mail.host=email-smtp.us-east-1.amazonaws.com
mail.port=465

#only required if mail.auth=true (the default)
mail.username="Smtp username as generated by Amazon"
mail.password="Smtp password"
```

`application.conf` can additionally contain the following information:
``` scala
#default is smtps
mail.transport.protocol=smtp

#default is true
mail.auth=false
```

Usage
-----

### Creating an email

``` scala
  import net.kaliber.mailer._

  Email(
    subject = "Test mail",
    from = EmailAddress("Erik Westra sender", "ewestra@rhinofly.nl"),
    text = "text",
    htmlText = "htmlText",
    replyTo = None,
    recipients = List(Recipient(
      RecipientType.TO, EmailAddress("Erik Westra recipient", "ewestra@rhinofly.nl"))),
    attachments = Seq.empty)

  // a more convenient way to create an email
  val email = Email(
    subject = "Test mail",
    from = EmailAddress("Erik Westra sender", "ewestra@rhinofly.nl"),
    text = "text",
    htmlText = "htmlText")
    .to("Erik Westra TO", "ewestra+to@rhinofly.nl")
    .cc("Erik Westra CC", "ewestra+cc@rhinofly.nl")
    .bcc("Erik Westra BCC", "ewestra+bcc@rhinofly.nl")
    .replyTo("Erik Westra REPLY_TO", "ewestra+replyTo@rhinofly.nl")
    .withAttachments(
      Attachment("attachment1", Array[Byte](0, 1), "application/octet-stream"),
      Attachment("attachment2", Array[Byte](0, 1), "application/octet-stream", Disposition.Inline))
```

### Sending an email synchronously

``` scala
  import net.kaliber.mailer._

  val result:Try[Unit] = Mailer.sendEmail(email)

  result match {
    case Success(_) =>
      //mail sent successfully
    case Failure(SendEmailException(email, cause)) =>
      //failed to send email, cause provides more information
    case Failure(SendEmailTransportCloseException(None, cause)) =>
        //failed to close the connection, no email was sent
    case Failure(SendEmailTransportCloseException(Some(Success(_)), cause)) =>
        //failed to close the connection, the email was sent
    case Failure(SendEmailTransportCloseException(Some(Failure(SendEmailException(email, cause1))), cause2)) =>
        //failed to close the connection, the email was not sent
  }

```

### Sending multiple emails synchronously

``` scala
  import net.kaliber.mailer._

  val result:Try[Seq[Try[Unit]]] = Mailer.sendEmails(email1, email2)

  result match {
    case Success(results) =>
      results.foreach {
        case Success(_) =>
          //mail sent successfully
        case Failure(SendEmailException(email, cause)) =>
          //failed to send email, cause provides more information
      }
    case Failure(SendEmailsTransportCloseException(None, cause)) =>
      //failed to close the connection, no email was sent
    case Failure(SendEmailsTransportCloseException(Some(Seq(Success(_), Failure(SendEmailException(email, cause1))), cause2)) =>
      //failed to close the connection, one of the emails was sent
  }
```

### Sending mail asynchonously

``` scala
  import net.kaliber.mailer._

  val result:Future[Unit] = AsyncMailer.sendEmail(email)

  result
    .map { unit =>
      // mail sent successfully
  }
  .recover {
    case SendEmailException(email, cause) =>
      // problem sending email
    case SendEmailTransportCloseException(result, cause) =>
      // problem closing connection
  }
```

### Sending mails asynchonously

``` scala
  import net.kaliber.mailer._

  val result:Future[Seq[Try[Unit]]] = AsyncMailer.sendEmails(email)

  result
    .map { results =>
      results.foreach {
        case Success(_) =>
          //mail sent successfully
        case Failure(SendEmailException(email, cause)) =>
          //failed to send email, cause provides more information
      }
    }
    .recover {
      case SendEmailException(email, cause) =>
        // problem sending email
      case SendEmailTransportCloseException(result, cause) =>
        // problem closing connection
    }
```
